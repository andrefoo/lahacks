// Controller for handling LLM API requests
const axios = require('axios');

// Sample initial nodes for fallback
const initialNodes = [
  { id: 1, label: "Decentralized Energy Grids", description: "Systems that distribute energy generation across multiple small-scale sources rather than centralized power plants." },
  { id: 2, label: "Renewable Energy Sources", description: "Energy sources that are naturally replenished on a human timescale, such as sunlight, wind, rain, tides, waves, and geothermal heat." },
  { id: 3, label: "Grid Resilience", description: "The ability of power systems to withstand and recover from extreme events and disruptions." },
  { id: 4, label: "Energy Storage Technologies", description: "Methods of storing energy for later use, including batteries, pumped hydro, and thermal storage." },
  { id: 5, label: "Microgrid Implementation", description: "Small-scale power grids that can operate independently or in coordination with the main grid." },
  { id: 6, label: "Smart Grid Technologies", description: "Digital technology that allows for two-way communication between utilities and consumers." },
  { id: 7, label: "Energy Democratization", description: "Shift of power from centralized entities to individuals and communities in energy production and distribution." },
  { id: 8, label: "Regulatory Frameworks", description: "Legal and policy structures governing energy production, distribution, and consumption." },
  { id: 9, label: "Community-Owned Energy", description: "Energy projects owned and operated by local communities rather than by corporations or governments." },
  { id: 10, label: "Grid Modernization", description: "Upgrading electricity infrastructure to improve reliability, efficiency, security, and integration of renewables." }
];

// Sample child nodes for fallback
const childNodesMap = {
  1: [
    { id: 101, label: "Peer-to-Peer Energy Trading", description: "Systems allowing consumers to buy and sell excess energy directly to each other." },
    { id: 102, label: "Blockchain for Energy", description: "Using distributed ledger technology to manage energy transactions." },
    { id: 103, label: "Virtual Power Plants", description: "Cloud-based distributed power plants that aggregate capacity from multiple sources." }
  ],
  2: [
    { id: 201, label: "Solar Photovoltaics", description: "Technology converting sunlight directly into electricity using semiconducting materials." },
    { id: 202, label: "Wind Power Systems", description: "Conversion of wind energy into electrical power using wind turbines." },
    { id: 203, label: "Hydroelectric Generation", description: "Electricity generated by the gravitational force of falling or flowing water." }
  ],
  // Add more as needed
};

/**
 * Generate a knowledge graph from a user prompt
 * Uses OpenAI or other LLM APIs to create nodes and relationships
 */
exports.generateGraph = async (req, res) => {
  try {
    const { prompt } = req.body;
    
    if (!prompt) {
      return res.status(400).json({ error: 'Prompt is required' });
    }
    
    // Check for API key
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      console.warn('No OpenAI API key found. Using fallback data.');
      return res.json({
        nodes: initialNodes,
        childNodesMap: childNodesMap
      });
    }
    
    // Create system prompt for the LLM to generate a knowledge graph
    const systemPrompt = `
      You are an AI specialized in generating knowledge graphs from user queries.
      Based on the user's topic, generate:
      1. 10 main nodes (concepts) related to the topic.
      2. For each main node, generate 3 child nodes that represent subtopics or related concepts.
      3. Ensure all nodes have a descriptive label (1-5 words) and a brief description (1-2 sentences).
      
      Format your response as a valid JSON object with the following structure:
      {
        "nodes": [
          { "id": 1, "label": "Main Concept 1", "description": "Description of concept 1" },
          { "id": 2, "label": "Main Concept 2", "description": "Description of concept 2" },
          ...
        ],
        "childNodesMap": {
          "1": [
            { "id": 101, "label": "Child of Concept 1", "description": "Description of child" },
            ...
          ],
          "2": [ ... ],
          ...
        }
      }
    `;
    
    // Call OpenAI API
    const response = await axios.post(
      'https://api.openai.com/v1/chat/completions',
      {
        model: 'gpt-3.5-turbo', // or 'gpt-4' for better results
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: 2000
      },
      {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        }
      }
    );
    
    // Parse the LLM response
    const content = response.data.choices[0].message.content.trim();
    let graphData;
    
    try {
      // Extract JSON from the response (in case there's additional text)
      const jsonMatch = content.match(/\{[\s\S]*\}/);
      const jsonString = jsonMatch ? jsonMatch[0] : content;
      graphData = JSON.parse(jsonString);
      
      // Validate the structure
      if (!graphData.nodes || !graphData.childNodesMap) {
        throw new Error('Invalid response structure');
      }
    } catch (parseError) {
      console.error('Error parsing LLM response:', parseError);
      // Use fallback data on parsing error
      graphData = {
        nodes: initialNodes,
        childNodesMap: childNodesMap
      };
    }
    
    // Return the graph data
    res.json(graphData);
    
  } catch (error) {
    console.error('Error generating graph:', error);
    
    // Return fallback data on error
    res.json({
      nodes: initialNodes,
      childNodesMap: childNodesMap
    });
  }
};

/**
 * Expand a specific node to get its child nodes
 * @param {Object} req - Express request object with nodeId parameter
 * @param {Object} res - Express response object
 */
exports.expandNode = async (req, res) => {
  try {
    const { nodeId } = req.params;
    const limit = req.query.limit ? parseInt(req.query.limit) : 3;
    
    // Validate nodeId
    const id = parseInt(nodeId);
    if (isNaN(id) || id <= 0) {
      return res.status(400).json({ error: 'Invalid node ID' });
    }

    // Check if we already have children for this node in our fallback data
    if (childNodesMap[id]) {
      return res.json({
        parentId: id,
        childNodes: childNodesMap[id].slice(0, limit)
      });
    }
    
    // Check for API key
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      console.warn('No OpenAI API key found. Using generated child nodes.');
      
      // Generate fallback children
      const childNodes = generateFallbackChildren(id, limit);
      return res.json({
        parentId: id,
        childNodes
      });
    }
    
    // Find the parent node to use its label as context
    const parentNode = initialNodes.find(node => node.id === id);
    if (!parentNode) {
      return res.status(404).json({ error: 'Node not found' });
    }
    
    // Create system prompt for the LLM to generate child nodes
    const systemPrompt = `
      You are an AI specialized in generating subtopics for knowledge graphs.
      Generate ${limit} child nodes/subtopics for the concept: "${parentNode.label}".
      Each child node should have a descriptive label (1-5 words) and a brief description (1-2 sentences).
      
      Format your response as a valid JSON array with the following structure:
      [
        { "id": ${id * 100 + 1}, "label": "Child Concept 1", "description": "Description of child concept 1" },
        { "id": ${id * 100 + 2}, "label": "Child Concept 2", "description": "Description of child concept 2" },
        ...
      ]
    `;
    
    // Call OpenAI API
    const response = await axios.post(
      'https://api.openai.com/v1/chat/completions',
      {
        model: 'gpt-3.5-turbo', 
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: `Generate subtopics for "${parentNode.label}"` }
        ],
        temperature: 0.7,
        max_tokens: 1000
      },
      {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        }
      }
    );
    
    // Parse the LLM response
    const content = response.data.choices[0].message.content.trim();
    let childNodes;
    
    try {
      // Extract JSON from the response (in case there's additional text)
      const jsonMatch = content.match(/\[[\s\S]*\]/);
      const jsonString = jsonMatch ? jsonMatch[0] : content;
      childNodes = JSON.parse(jsonString);
      
      // Validate the structure
      if (!Array.isArray(childNodes) || childNodes.length === 0) {
        throw new Error('Invalid response structure');
      }
    } catch (parseError) {
      console.error('Error parsing LLM response:', parseError);
      // Use fallback data on parsing error
      childNodes = generateFallbackChildren(id, limit);
    }
    
    // Return the child nodes
    res.json({
      parentId: id,
      childNodes
    });
    
  } catch (error) {
    console.error('Error expanding node:', error);
    
    // Generate fallback children on error
    const id = parseInt(req.params.nodeId);
    const limit = req.query.limit ? parseInt(req.query.limit) : 3;
    
    res.json({
      parentId: id,
      childNodes: generateFallbackChildren(id, limit)
    });
  }
};

/**
 * Generate fallback child nodes for a parent ID
 * @param {number} parentId - Parent node ID
 * @param {number} limit - Number of children to generate
 * @returns {Array} - Array of child nodes
 */
function generateFallbackChildren(parentId, limit = 3) {
  const baseChildId = parentId * 100;
  const nodeTopics = [
    { label: "Implementation Challenges", description: "Obstacles and difficulties faced during practical application and deployment." },
    { label: "Future Developments", description: "Anticipated advancements and innovations expected in coming years." },
    { label: "Cost Analysis", description: "Examination of economic factors, expenses, and financial implications." },
    { label: "Regulatory Aspects", description: "Legal frameworks, policies, and compliance requirements." },
    { label: "Case Studies", description: "Examination of real-world examples and their outcomes." },
    { label: "Technical Specifications", description: "Detailed technical requirements and parameters." }
  ];
  
  return Array.from({ length: limit }, (_, index) => {
    const topicIndex = (parentId + index) % nodeTopics.length;
    return {
      id: baseChildId + index + 1,
      label: nodeTopics[topicIndex].label,
      description: nodeTopics[topicIndex].description
    };
  });
} 