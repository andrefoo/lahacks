// Service for interacting with the LLM API
// Handles fetching graph data based on user prompts

import { detectBiases } from './biasDetection';

// Sample initial nodes as fallback
const initialNodes = [
  { id: 1, label: "Decentralized Energy Grids", description: "Systems that distribute energy generation across multiple small-scale sources rather than centralized power plants.", hasBias: true, biasType: "Technological Solutionism", biasDescription: "Overemphasizing technology as the solution to complex social, economic, and political problems." },
  { id: 2, label: "Renewable Energy Sources", description: "Energy sources that are naturally replenished on a human timescale, such as sunlight, wind, rain, tides, waves, and geothermal heat." },
  { id: 3, label: "Grid Resilience", description: "The ability of power systems to withstand and recover from extreme events and disruptions." },
  { id: 4, label: "Energy Storage Technologies", description: "Methods of storing energy for later use, including batteries, pumped hydro, and thermal storage.", hasBias: true, biasType: "Confirmation Bias", biasDescription: "Favoring information that confirms existing beliefs while giving less attention to alternative possibilities." },
  { id: 5, label: "Microgrid Implementation", description: "Small-scale power grids that can operate independently or in coordination with the main grid." },
  { id: 6, label: "Smart Grid Technologies", description: "Digital technology that allows for two-way communication between utilities and consumers." },
  { id: 7, label: "Energy Democratization", description: "Shift of power from centralized entities to individuals and communities in energy production and distribution.", hasBias: true, biasType: "Overconfidence Bias", biasDescription: "Overestimating one's abilities, knowledge, or the accuracy of one's beliefs." },
  { id: 8, label: "Regulatory Frameworks", description: "Legal and policy structures governing energy production, distribution, and consumption." },
  { id: 9, label: "Community-Owned Energy", description: "Energy projects owned and operated by local communities rather than by corporations or governments." },
  { id: 10, label: "Grid Modernization", description: "Upgrading electricity infrastructure to improve reliability, efficiency, security, and integration of renewables.", hasBias: true, biasType: "Status Quo Bias", biasDescription: "Preference for the current state of affairs and resistance to change." }
];

// Sample child nodes as fallback
const childNodesMap = {
  1: [
    { id: 101, label: "Peer-to-Peer Energy Trading", description: "Systems allowing consumers to buy and sell excess energy directly to each other." },
    { id: 102, label: "Blockchain for Energy", description: "Using distributed ledger technology to manage energy transactions.", hasBias: true, biasType: "Shiny Object Bias", biasDescription: "Favoring new, exciting technologies over established solutions that may work better." },
    { id: 103, label: "Virtual Power Plants", description: "Cloud-based distributed power plants that aggregate capacity from multiple sources." }
  ],
  2: [
    { id: 201, label: "Solar Photovoltaics", description: "Technology converting sunlight directly into electricity using semiconducting materials." },
    { id: 202, label: "Wind Power Systems", description: "Conversion of wind energy into electrical power using wind turbines." },
    { id: 203, label: "Hydroelectric Generation", description: "Electricity generated by the gravitational force of falling or flowing water." }
  ],
  // Add more child nodes for each parent node
};

/**
 * Fetch graph data from the LLM API based on user prompt
 * In a real implementation, this would call an external API
 */
export const fetchGraphData = async (prompt) => {
  try {
    // In a real implementation, call the server endpoint
    // For now, simulate a delay and return hardcoded data for testing
    const endpoint = '/api/generate-graph';
    
    // If we're in development mode or don't have actual API yet, use mock data
    if (process.env.NODE_ENV === 'development' || !endpoint) {
      await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate API delay
      
      // For testing, use the hardcoded data
      return {
        nodes: initialNodes,
        childNodesMap: childNodesMap
      };
    }
    
    // In production, make the actual API call
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ prompt }),
    });
    
    if (!response.ok) {
      throw new Error('Failed to fetch graph data');
    }
    
    const data = await response.json();
    
    // Process the nodes to detect biases
    const nodesWithBiases = detectBiases(data.nodes);
    
    return {
      ...data,
      nodes: nodesWithBiases
    };
  } catch (error) {
    console.error('Error fetching graph data:', error);
    
    // Return fallback data
    return {
      nodes: initialNodes,
      childNodesMap: childNodesMap
    };
  }
}; 