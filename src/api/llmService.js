// Service for interacting with the LLM API
// Handles fetching graph data based on user prompts

import { detectBiases } from './biasDetection';

// Sample initial nodes as fallback
const initialNodes = [
  { id: 1, label: "Decentralized Energy Grids", description: "Systems that distribute energy generation across multiple small-scale sources rather than centralized power plants.", hasBias: true, biasType: "Technological Solutionism", biasDescription: "Overemphasizing technology as the solution to complex social, economic, and political problems." },
  { id: 2, label: "Renewable Energy Sources", description: "Energy sources that are naturally replenished on a human timescale, such as sunlight, wind, rain, tides, waves, and geothermal heat." },
  { id: 3, label: "Grid Resilience", description: "The ability of power systems to withstand and recover from extreme events and disruptions." },
  { id: 4, label: "Energy Storage Technologies", description: "Methods of storing energy for later use, including batteries, pumped hydro, and thermal storage.", hasBias: true, biasType: "Confirmation Bias", biasDescription: "Favoring information that confirms existing beliefs while giving less attention to alternative possibilities." },
  { id: 5, label: "Microgrid Implementation", description: "Small-scale power grids that can operate independently or in coordination with the main grid." },
  { id: 6, label: "Smart Grid Technologies", description: "Digital technology that allows for two-way communication between utilities and consumers." },
  { id: 7, label: "Energy Democratization", description: "Shift of power from centralized entities to individuals and communities in energy production and distribution.", hasBias: true, biasType: "Overconfidence Bias", biasDescription: "Overestimating one's abilities, knowledge, or the accuracy of one's beliefs." },
  { id: 8, label: "Regulatory Frameworks", description: "Legal and policy structures governing energy production, distribution, and consumption." },
  { id: 9, label: "Community-Owned Energy", description: "Energy projects owned and operated by local communities rather than by corporations or governments." },
  { id: 10, label: "Grid Modernization", description: "Upgrading electricity infrastructure to improve reliability, efficiency, security, and integration of renewables.", hasBias: true, biasType: "Status Quo Bias", biasDescription: "Preference for the current state of affairs and resistance to change." }
];

// Sample child nodes as fallback
const childNodesMap = {
  1: [
    { id: 101, label: "Peer-to-Peer Energy Trading", description: "Systems allowing consumers to buy and sell excess energy directly to each other." },
    { id: 102, label: "Blockchain for Energy", description: "Using distributed ledger technology to manage energy transactions.", hasBias: true, biasType: "Shiny Object Bias", biasDescription: "Favoring new, exciting technologies over established solutions that may work better." },
    { id: 103, label: "Virtual Power Plants", description: "Cloud-based distributed power plants that aggregate capacity from multiple sources." }
  ],
  2: [
    { id: 201, label: "Solar Photovoltaics", description: "Technology converting sunlight directly into electricity using semiconducting materials." },
    { id: 202, label: "Wind Power Systems", description: "Conversion of wind energy into electrical power using wind turbines." },
    { id: 203, label: "Hydroelectric Generation", description: "Electricity generated by the gravitational force of falling or flowing water." }
  ],
  // Add more child nodes for each parent node
};

/**
 * Fetch graph data from the LLM API based on user prompt
 * @param {string} prompt - User's input prompt
 * @returns {Object} - Knowledge graph data with nodes and childNodesMap
 */
export const fetchGraphData = async (prompt) => {
  try {
    // In a real implementation, call the server endpoint
    // For now, simulate a delay and return hardcoded data for testing
    const endpoint = '/api/generate-graph';
    
    // If we're in development mode or don't have actual API yet, use mock data
    if (process.env.NODE_ENV === 'development' && window.location.hostname === 'localhost' && !window.forceApiCall) {
      await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate API delay
      
      // For testing, use the hardcoded data
      return {
        nodes: initialNodes,
        childNodesMap: childNodesMap
      };
    }
    
    // In production, make the actual API call
    const response = await fetch(endpoint, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ prompt }),
    });
    
    if (!response.ok) {
      throw new Error('Failed to fetch graph data');
    }
    
    const data = await response.json();
    
    // Process the nodes to detect biases
    const nodesWithBiases = detectBiases(data.nodes);
    
    return {
      ...data,
      nodes: nodesWithBiases
    };
  } catch (error) {
    console.error('Error fetching graph data:', error);
    
    // Return fallback data
    return {
      nodes: initialNodes,
      childNodesMap: childNodesMap
    };
  }
};

/**
 * Fetch child nodes for a specific parent node
 * @param {number} nodeId - ID of the parent node
 * @param {number} limit - Maximum number of children to return
 * @returns {Object} - Object containing parentId and childNodes array
 */
export const fetchNodeChildren = async (nodeId, limit = 3) => {
  try {
    // In a real implementation, call the server endpoint
    const endpoint = `/api/expand-node/${nodeId}?limit=${limit}`;
    
    // If we're in development mode, use mock data if available
    if (process.env.NODE_ENV === 'development' && window.location.hostname === 'localhost' && !window.forceApiCall) {
      await new Promise(resolve => setTimeout(resolve, 800)); // Simulate API delay
      
      // Return hardcoded children if available
      if (childNodesMap[nodeId]) {
        return {
          parentId: nodeId,
          childNodes: childNodesMap[nodeId].slice(0, limit)
        };
      }
      
      // Generate mock children for testing
      const childNodes = Array.from({ length: limit }, (_, i) => ({
        id: nodeId * 100 + i + 1,
        label: `Child Node ${i + 1}`,
        description: `This is a mock child node for parent ${nodeId}.`
      }));
      
      return {
        parentId: nodeId,
        childNodes
      };
    }
    
    // Make the actual API call
    const response = await fetch(endpoint);
    
    if (!response.ok) {
      throw new Error(`Failed to expand node ${nodeId}`);
    }
    
    const data = await response.json();
    
    // Process child nodes to detect biases
    if (data.childNodes && Array.isArray(data.childNodes)) {
      data.childNodes = detectBiases(data.childNodes);
    }
    
    return data;
  } catch (error) {
    console.error(`Error fetching children for node ${nodeId}:`, error);
    
    // Return fallback children
    const fallbackChildren = childNodesMap[nodeId] || 
      Array.from({ length: limit }, (_, i) => ({
        id: nodeId * 100 + i + 1,
        label: `Child Node ${i + 1}`,
        description: `Fallback child node for parent ${nodeId}.`
      }));
    
    return {
      parentId: nodeId,
      childNodes: fallbackChildren.slice(0, limit)
    };
  }
};

/**
 * Check if the API server is healthy
 * @returns {boolean} - Whether the API server is available
 */
export const checkApiHealth = async () => {
  try {
    const response = await fetch('/api/health');
    
    if (!response.ok) {
      return false;
    }
    
    const data = await response.json();
    return data.status === 'ok';
  } catch (error) {
    console.error('API health check failed:', error);
    return false;
  }
}; 